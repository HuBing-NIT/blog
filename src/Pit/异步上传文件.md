---
title: 异步上传文件
order: 6
nav:
  title: 踩坑
  path: /blogs
group:
  title: 遇到的坑
  path: /遇到的坑
  order: 2
---

# 6. 异步上传文件

## 需求描述

```
  需要实现一个文件上传功能,即使页面切换,上传请求仍需要在后台保持上传状态.
```

## 心路历程

```
  文件上传我一般只用过antd的Upload组件, 可以实现绝大部分文件上传的功能. 但是组件写在某个页面内的, 一旦页面切换就会中断文件上传, 显然是不好的。
最初试了下把Upload组件放置到全局的位置, 以此去调用上传, 后来觉得有些奇怪. 最终选择了使用XmlHttpRequeest来实现, 但我觉得Upload应该也能实现。
```

## 需求解析

```javascript
  本文以案件为例子 一个案件可能有多个相关的图片和视频
  具体实现和功能不做详细代码说明
1. 支持文件上传(后台异步)
2. 一次只上传一个文件(http请求只能最多请求5个, 超过后页面会阻塞)


```

## Code 部分

### 状态定义

```javascript
// 根据可能出现的上传中的情况, 大概列举了如下的状态
const UPLOAD_STATUS = {
  Error: 'error', // 上传出错
  Uploading: 'uploading', // 上传中
  Wait: 'wait', // 等待上传
  Done: 'done', // 上传完成
  MD5Exist: 'Md5Exist', // md5重复文件
  SIZEERROR: 'SizeError', // 文件过大
  TimeOut: 'Timeout', // 上传超时
};
```

### 实现 FileBindMgr 类

```javascript
  class FileBindMgr extends EventEmitter {
    private static inst = new FileBindMgr();

    private caseMap: Map<string, string> = new Map(); // 案件id和uuid的绑定关系 通过案件id找到uuid
    // 数据格式如下
    // {
    //   key:'321321',
    //   value: 'u8sw2dnl'
    // }

    private fileMap: Map<string, IFileMapValueType> = new Map(); // uuid 和 案件id 文件列表的绑定关系
    // fileMap是所有数据的核心 用Map类型存储
    // {
    //     "key": "u8sw2dnl", // 随机8位字符串
    //     "value": {
    //         "caseId": null,
    //         "fileList": {
    //           "u8sw2dnl-tycu": {
    //           "percent": 61,
    //           "uid": "u8sw2dnl-tycu",
    //           "size": 15650102,
    //           "type": "video/mp4",
    //           "status": "uploading",
    //           "name": "35.mp4",
    //           "user": "0"
    //           }
    //         },
    //         "historyFile": {
    //             "0": []
    //         }
    //     }
    // }

    private uploadQueue:IUploadFileParamType[] = []; // 上传队列

    private uploadingCount: number = 0; // 上传中的个数

    private curPageUuid: string = '';

    private MaxfileSize = 10;

    constructor() {
      super();
      this.setMaxListeners(100);
      window.addEventListener('beforeunload', (event) => {
        if (this.uploadingCount + this.uploadQueue.length !== 0) {
          event.returnValue = '还有没上传的文件 是否关闭窗口';
        }
      });
    }

    public sumbitUpload = (files, _, _) => {
      // <Input type='file'>表现选择多个文件后执行该函数
      const arr = Object.values(files);
      arr.map((i)=>{
         if (i.size > this.MaxfileSize * 1024 * 1024) { // 超过文件大小限制
            //...
            return;
         }
          this.fileMap.set(uuid, n);
          if (this.uploadingCount < 1) {
            this.fetchFileUpload() // 正式上传
            this.uploadingCount += 1;
          } else { // 加入队列等待上传
            this.uploadQueue.push({
              file: i, uuid, userId, uid
            })
            this.recordQueueLength()
          }
      })
    }

    // XML请求
    public featchFileSumbit = () => {
      const xhr = new XMLHttpRequest();
      const formData = new FormData();
      formData.append('uploadFile', file)
      xhr.open('post', `${API_HOST}/files`, true); // 上传接口
      // xhr.timeout = 10000;
      xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) {
          // 更新进度
          const percent = Math.round(e.loaded / e.total * 100) // 进度计算
          //...
        }
      }
      xhr.ontimeout = () => {
        // ...
        this.startNextFeatch()
      }
      xhr.onerror = () => { // 请求失败了
        // ...
        this.startNextFeatch()
      }
      xhr.onabort = () => { // 请求中断了 请求中删除了
        // ...
        this.startNextFeatch()
      }
      xhr.onreadystatechange = () => {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) { // 上传成功了
            // ...
            this.startNextFeatch()
            // ...
          } else { // 上传出错了
            // ...
            this.startNextFeatch()
          }
        }
      }
      xhr.send(formData)
    }
    // 开始下一次队列请求
    private startNextFeatch = () => {
      // 当之前的文件传输成功 失败 超时 各种情况下就要把队列取出 进行下一个文件的上传 
      this.uploadingCount = this.uploadingCount === 0 ? 0 : this.uploadingCount -= 1;
      const next = this.uploadQueue.pop()
      next && this.fetchFileUpload(next)
      this.recordQueueLength()
    }
  }

  export default FileBindMgr;
```

## 总结
```javascript
  这是我个人项目中遇到的一个文件上传的需求. 真实情况更加复杂. 真实代码有700行, 但显然还是有很多优化空间. 也不够通用。
  这里只放了部分简单的代码, 只为了自己做个记录, 防止以后遇到同样的问题. 希望以后自己能出个通俗易懂的版本.
```