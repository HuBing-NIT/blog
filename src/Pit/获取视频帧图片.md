---
title: 获取视频帧图片
order: 5
nav:
  title: 踩坑
  path: /blogs
group:
  title: 遇到的坑
  path: /遇到的坑
  order: 2
---

# 5. 获取视频的帧图像

## 描述
```
  通过上传一段视频.上传成功后拿到视频某一帧的画面
```


## 代码Code
```javascript
  // 入参url 视频上传后后端返回的path路径(http://xxx.x.xx)
  const getVideoBase64 = (url) => {
    const id = 'videoFirst'
    return new Promise((resolve) => {
      // 创建video标签
      const video = document.createElement('video');
      video.setAttribute('crossOrigin', 'anonymous'); // 处理跨域
      video.setAttribute('src', url);
      video.setAttribute('id', id)
      video.currentTime = 10; // 当前帧
      video.addEventListener('loadeddata', (e) => {
        const canvas = document.createElement('canvas');
        canvas.width = video.clientWidth;
        canvas.height = video.clientHeight;
        canvas.getContext('2d').drawImage(video, 0, 0, video.clientWidth, video.clientHeight); // 绘制canvas
        const dataURL = canvas.toDataURL('image/jpeg'); // 转换为base64;
        document.body.removeChild(document.getElementById(id))
        resolve(dataURL)
      });
      document.body.appendChild(video)
    })
  }

```



## 注意点

```
video.clientWidth/video.clientHeight的值要根据页面真实dom中的video Dom获取.
如果不执行document.body.appendChild(video) 那么video.clientWidth/video.clientHeight均为0
赋值给canvas的画布大小也为0×0, 最终无法获取视频第N帧的截图. 
```

## 解决方案

```
因为on('loadeddata')是异步的, 先将video dom 插入到页面中. 再loadeddata监听执行后, 此时Video dom存在于页面
可以获取到其真实的ClientWidth/ClientHeight, 紧接着将video dom 移除即可.
因为对用户来说 整个过程无感知.
```





